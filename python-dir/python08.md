# 字符编码

## 阅读目录

- 一、了解字符编码的知识储备
- 二、字符编码
- 三、字符编码的发展历程
- 四、字符编码总结
---
- 一、了解字符编码的知识储备
  - 1、文本编辑器读取文件的过程

  ```python
  # 打开文本编辑器

  # 文本编辑器将文件内容当做普通字符从硬盘读入内存中

  # 通过输出设备，将文件内容打印到屏幕上
  ```

  - 2、Python解释器解释执行py文件的过程（Python first.py）

  ```Python
  # 1、打开Python解释器，此时就相当打开了一个普通的文本编辑器

  # 2、python解释器将first.py的文件内容当做普通字符读入内存(此阶段不会识别Python语法)

  # 3、Python解释器解释执行first.py的代码内容，并检查Python语法
  ```
  - 总结

  ```Python
  # 前两个阶段，Python解释器和普通文本编辑器无异

  # 只有在第三阶段，python解释器才会识别Python语法

  # 注意：文本编辑器或者python解释器在第二三阶段，会涉及到字符编码的概念
  ```

- 二、字符编码

```Python
# 字符编码表就一个存有字符与数字的对应关系的表

# 数据在硬盘上是以二进制的格式存储

# 存文件涉及到字符编码过程：
万国字符（gbk，ASCII）————编码（encode）—————二进制（数字0和1）

# 读取文件涉及到的字符编码过程：

二进制—————解码（decode）——————万国字符
```

- 三、字符编码的发展历程

```Python
# 阶段一：现代计算机起源于美国，最早诞生也是基于英文考虑的ASCII
# ASCII：一个Bytes代表一个字符   1Bytes=8bit  8Bit可以表示2**8中变化，即可以表示256个字符

# 阶段二：为了满足中文和英文，中国人制定了GBK
# GBK：2Bytes表示一个中文字符    1Bytes表示一个英文字符

# 阶段三：各国有各自的字符编码标准，就会不能避免的出现冲突，结果就是，在多语言混合的文本中，显示会有乱码

# 阶段四：为了解决乱码问题，Unicode出现
# Unicode：统一使用2Bytes表示一个字符，虽然2**16=65535，但Unicode却可以存放100w+个字符
# 因为Unicode存放了与其他编码的映射关系，准确的说Unicode并不是一种严格意义上的字符编码表，而是万国字符之间共存的一个介质

# 阶段五：如果文件内容都是英文字符，很显然Unicode浪费了一倍的存储空间吗，于是就utf-8出现了
# utf8：1Bytes表示一个英文字符   3Bytes表示一个中文字符，对中文其他生僻字用跟多的Bytes去存

#　总结：
    # 内存中统一采用Unicode，浪费空间来换取可以转换成任意编码（不乱码）
    # 硬盘中采用各种编码，如utf8，保证存放于硬盘或者基于网络传输的数据量很小，提高传输效率与稳定性
```

- 四、字符编码总结

```Python
# 1、但凡出现乱码问题，一定是编码时用了一套字符编码，解码时用了另一套字符编码

# 2、解决乱码问题核心：编码时用什么编码存，解码时就用什么编码解

# 3、python3解释器默认使用utf-8    Python2解释器默认使用ASCII

# 4、文件开头:#coding:gbk 用来告诉解释器读文件内容时，用什么编码

# 5、Python3中str类型内存用的是Unicode编码的二级制
```
